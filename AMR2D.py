import TopFileTool
from Utility import *


'''
Implement the algorithm in

Bartels, SÃ¶ren, and Patrick Schreier. "Local coarsening of simplicial finite element meshes generated by bisections."
BIT Numerical Mathematics 52.3 (2012): 559-569.

Stevenson, Rob. "The completion of locally refined simplicial partitions created by bisection."
Mathematics of computation 77.261 (2008): 227-241.
APA


Slightly modified from
Maubach, Joseph M. "Local bisection refinement for n-simplicial grids generated by reflection."
SIAM Journal on Scientific Computing 16.1 (1995): 210-227.
'''





class MarkedTri():
    def __init__(self, nn, bFlag = False):
        '''
        :param nn: n0,n1,n2, the order is in counter-clockwise order

        constructor for markedTri
        nn = [n0, n1, n2]
        n0 is always the newest node and always bisect n1-n2
        '''
        self.nn = nn
        self.bFlag = bFlag

    def get_newest_node(self):
        nn = self.nn
        return nn[0]

    def get_ref_edge(self):
        nn = self.nn
        return [nn[1], nn[2]]



    def bisect_tri(self, n, bFlag = False):
        '''
        bisect the tet
        :param n: new node number
        :return: return two marked tri
        bisect the tri into 2
        T = (n0, n1, n2)
        s1(T) = (y, n0, n1)
        s2(T) = (y, n2, n0)
        '''

        nn = self.nn

        return MarkedTri([n, nn[0], nn[1]], bFlag), \
               MarkedTri([n, nn[2], nn[0]], bFlag)










class Amr2DMesh():

    def __init__(self, mshfile):
        '''
        nodes: a list of float[3], node coordinates
        midNode: map from edge pair (a,b) a<b,  to its midpoint id
                 If it does not have midpoint node, the midpoint id is -1.
                 This array is used to detect hanging nodes
        markedElems: a list of markedTet class
        initElems: a list of int[4], original mesh element nodes


        :param mshfile:
        '''
        nodes, initElems, initBoundaryNames, initBoundaries = TopFileTool.read_tri(mshfile)

        self.nodes = nodes
        self.initElems = initElems
        self.initBoundaryNames = initBoundaryNames

        #build dictionary edge->midNode
        self._build_mid_node()

        self._build_boundary_edges(initBoundaries)

        self._build_marked_elems()


    def _build_mid_node(self):
        '''
        This function should only be called in the class constructor, it uses initElems
        to initialize midNode mesh
        '''

        initElems = self.initElems
        midNode = {}
        for e in range(len(initElems)):
            nodes = initElems[e]
            for i in range(3):
                for j in range(i + 1, 3):
                    midNode[pair_sort(nodes[i], nodes[j])] = -1

        self.midNode = midNode


    def _build_marked_elems(self):
        '''
        This function should only be called in the class constructor, it uses initElems
        to initialize marked elements
        '''
        initElems = self.initElems
        boundaries = self.boundaries
        markedElems = []

        for ele in initElems:
            bFlag = False
            if(pair_sort(ele[0], ele[1]) in boundaries or
                    pair_sort(ele[1], ele[2]) in boundaries or
                    pair_sort(ele[2], ele[0]) in boundaries):
                bFlag = True
            markedElems.append(MarkedTri([ele[0], ele[1], ele[2]], bFlag))

        self.markedElems = markedElems

    def _build_boundary_edges(self, initBoundaries):
        '''
        This function should only be called in the class constructor, it uses initElems
        to initialize marked elements
        '''
        boundaries = {}
        bcId = 0
        for initBoundary in initBoundaries:
            for i,j in initBoundary:
                boundaries[pair_sort(i,j)] = bcId
            bcId = bcId + 1
        self.boundaries = boundaries

    def _update_boundary_eles(self):
        '''
        This function should only be called in the class constructor, it uses initElems
        and boundaries to update the boundary flag in marked elements
        '''
        markedElems = self.markedElems
        boundaries = self.boundaries
        for e in markedElems:

            nn = e.nn
            if((pair_sort(nn[0],nn[1]) in boundaries) or (pair_sort(nn[1],nn[2]) in boundaries) or
               (pair_sort(nn[1],nn[2]) in boundaries)):
                e.bFlag = True


    def bisection(self, rElems):
        '''
        rElems: element list, need to be refined
        update: nodes, markedElems, midNode
        '''
        nodes = self.nodes
        markedElems = self.markedElems
        midNode = self.midNode
        boundaries = self.boundaries

        for e in rElems:
            elem = markedElems[e]
            newNode = midNode[pair_sort(*elem.get_ref_edge())]
            if(newNode == -1):
                #The edge is cut first time, add a new node(the midpoint),
                newNode = len(nodes)
                n0,nd = elem.get_ref_edge()
                y = [(nodes[n0][0] + nodes[nd][0]) / 2.0, (nodes[n0][1] + nodes[nd][1]) / 2.0]
                nodes.append(y)
                #mark the refined edge's midpoint
                midNode[pair_sort(*elem.get_ref_edge())] = newNode

                #add new edge, for there are 4 new edges
                for n in elem.nn:
                    midNode[pair_sort(n, newNode)] = -1

            else:
                #add new edges, for there are potentially 2 new edges on the cut faces
                n = elem.get_newest_node()
                if pair_sort(n, newNode) not in midNode:
                    midNode[pair_sort(n, newNode)] = -1

            # update boundary faces, for boundary elements
            if(elem.bFlag):
                #the element is potentially on the boundary
                i, j = elem.get_ref_edge()
                print("Refine boundary edge")
                if pair_sort(i,j) in boundaries:

                    bcId = boundaries.pop(pair_sort(i,j))
                    boundaries[pair_sort(i, newNode)] = bcId
                    boundaries[pair_sort(j, newNode)] = bcId


            # add new elements
            elem0, elem1 = elem.bisect_tri(newNode, elem.bFlag)
            markedElems[e] = elem0
            markedElems.append(elem1)


    def _nonconformity(self,e):
        '''
        loop the element's all edges, check it has hanging nodes or not
        :param e: element id
        :return: True: has hanging nodes, otherwise False
        '''
        elem = self.markedElems[e]
        midNode = self.midNode
        nn = elem.nn
        for i in range(3):
            for j in range(i+1,3):
                if midNode[pair_sort(nn[i],nn[j])] >= 0:
                    return True


    def check_conformity(self):
        '''
        check whether current mesh conforming or not
        :return: rElems: a list of element id. These elements have hanging nodes, need to be cut
        '''
        markedElems = self.markedElems
        nElems = len(markedElems)
        rElems = []
        for e in range(nElems):
            if self._nonconformity(e):
                rElems.append(e)
        return rElems


    def refine_by_elem(self, rElems):
        '''
        Refine mesh
        :param rElems: a list of int, for marked element ids to be refined
        :return:
        '''
        print('Refining mesh by elements...')
        while rElems:
            print('In Refining mesh loop, for %d elements...' %(len(rElems)))
            self.bisection(rElems)
            rElems = self.check_conformity()







    def coarsen(self):
        #todo
        print('todo, have not implemented yet')

    def output_to_top(self,mshfile):
        '''
        output the results to top file
        :param mshfile: output top file name
        :return:
        '''
        nodes = self.nodes
        markedElems = self.markedElems
        elems = []
        for i in range(len(markedElems)):
            elems.append(markedElems[i].nn)



        initBoundaryNames = self.initBoundaryNames

        boundaries = [[] for i in range(len(initBoundaryNames))]
        for edge in self.boundaries:
            boundaries[self.boundaries[edge]].append(edge)

        TopFileTool.write_tri(nodes, elems, initBoundaryNames, boundaries, mshfile)


    def plot_mesh(self, figfile="domain.png"):
        nodes = self.nodes
        markedElems = self.markedElems
        elems = []
        for i in range(len(markedElems)):
            elems.append(markedElems[i].nn)

        initBoundaryNames = self.initBoundaryNames

        boundaries = [[] for i in range(len(initBoundaryNames))]
        for edge in self.boundaries:
            boundaries[self.boundaries[edge]].append(edge)

        TopFileTool.plot_tri(nodes, elems, initBoundaryNames, boundaries, figfile)


    def find_point(self, point):
        '''
        find elements that contains this point
        :param point: float[2]
        :return: a list of element ids
        '''
        markedElems = self.markedElems
        nodes = self.nodes
        nElems = len(markedElems)
        rElems = []
        for e in range(nElems):
            ele = markedElems[e]
            xy = np.array([nodes[ele.nn[0]],nodes[ele.nn[1]],nodes[ele.nn[2]]])
            if inside_tri(xy, point):
                rElems.append(e)
        return rElems


    def find_line(self, line):
        '''
        find elements that contains this point
        :param line: float[4] x0,y0 --- x1,y1
        :return: a list of element ids
        '''
        markedElems = self.markedElems
        nodes = self.nodes
        nElems = len(markedElems)
        rElems = []
        for e in range(nElems):
            ele = markedElems[e]
            xy = np.array([nodes[ele.nn[0]],nodes[ele.nn[1]],nodes[ele.nn[2]]])
            if intersect_tri(xy, line):
                rElems.append(e)
        return rElems


if __name__ == '__main__':
    print('AMR Mesh Maubach')
    test = 1
    if(test == 0):
        amrMesh = Amr2DMesh('domain.top')
        refineLevel = 4
        singularity = np.array([0.3,0.4])
        for i in range(refineLevel):
            rElems = amrMesh.find_point(singularity)
            amrMesh.refine_by_elem(rElems)
        amrMesh.output_to_top('Refined_mesh.top')
        amrMesh.plot_mesh('Refined_mesh.png')

    if(test == 1):
        amrMesh = Amr2DMesh('domain.top')
        refineLevel = 3
        line = np.array([0.3, 0.4, 1.0, 0.8])
        for i in range(refineLevel):
            rElems = amrMesh.find_line(line)
            amrMesh.refine_by_elem(rElems)
        amrMesh.output_to_top('Refined_mesh.top')
        amrMesh.plot_mesh('Refined_mesh.png')












